# Implementation Plan: Game Loop Improvements
## Step-by-Step Guide for Multi-Day Implementation

---

## ðŸ“… **Overview**

**Total Duration**: 5-7 days (depending on complexity and testing)
**Goal**: Transform the game loop from monolithic structure to modern, maintainable architecture

**Success Criteria**:
- âœ… Game runs with same functionality as before
- âœ… Code is organized into scenes
- âœ… No global variables in main.cpp
- âœ… Event system decouples objects
- âœ… Component system allows composition

---

## ðŸŽ¯ **Pre-Implementation Checklist**

Before starting, ensure:
- [ ] Current game compiles and runs successfully
- [ ] All current features work (save/load, menu, gameplay)
- [ ] Git repository is clean (commit current state)
- [ ] Backup of current working code
- [ ] Understanding of current codebase structure

**Create Backup Branch:**
```bash
git checkout -b backup-before-refactor
git add .
git commit -m "Backup before game loop refactoring"
git checkout -b refactor-game-loop
```

---

## ðŸ“† **Day 1: Foundation & Code Extraction**

### **Goal**: Extract game logic from main.cpp and create basic structure

### **Tasks**

#### **Task 1.1: Create New Directory Structure** (30 min)
**Action**: Create folders for new architecture

```bash
# In project root
mkdir "Lion's Den/Scenes"
mkdir "Lion's Den/Components"
mkdir "Lion's Den/Systems"
mkdir "Lion's Den/Game"
```

**Files to Create**:
- `Lion's Den/Scenes/Scene.h` (empty for now)
- `Lion's Den/Scenes/Scene.cpp` (empty for now)
- `Lion's Den/Systems/SceneManager.h` (empty for now)
- `Lion's Den/Systems/SceneManager.cpp` (empty for now)

**Checkpoint**: Folders exist, empty header files created

---

#### **Task 1.2: Extract Game Logic to Game.cpp** (2-3 hours)
**Action**: Move game-specific code from main.cpp to separate file

**Steps**:

1. **Create `Lion's Den/Game/Game.h`**:
```cpp
#ifndef GAME_H_
#define GAME_H_

#include "Engine.h"
#include "Player.h"
#include "Map.h"
#include "Monster.h"
#include "GUI/Widgets/Box.h"
#include "GUI/Widgets/Button.h"
#include "GUI/Widgets/StatsBar.h"
#include "GUI/Widgets/Inventory.h"
#include <string>

// Forward declarations
class Game {
public:
    static Game& GetInstance();
    
    // Game lifecycle
    void Initialize();
    void Shutdown();
    
    // Game state callbacks (called from Engine)
    void OnGameInit();
    void OnGameEvent(SDL_Event* event, const Uint8* keyboardState);
    void OnGameUpdate();
    void OnGameRender();
    void OnGameCleanup();
    
    // Game state management
    enum GameState {
        PAUSE = 0,
        NEW_GAME,
        LOAD_GAME,
        SAVE_GAME,
        MAIN_MENU,
        PAUSE_MENU,
        PLAY
    };
    
    GameState GetState() const { return _gameState; }
    void SetState(GameState state) { _gameState = state; }
    
    // Save/Load
    void SaveGame();
    void LoadGame(const std::string& saveName);
    void NewGame(const std::string& saveName);
    
private:
    Game() = default;
    GameState _gameState = MAIN_MENU;
    std::string _savename;
    
    // Game objects (moved from globals)
    Object* layer_gui;
    Object* layer_player;
    
    Box* GuiBox_MainMenu;
    Box* GuiBox_MenuOptions;
    StatsBar* GuiBox_StatsBar;
    Inventory* Player_Inventory;
    
    Button* GuiButton_MainMenu_Start;
    Button* GuiButton_MainMenu_Options;
    Button* GuiButton_MainMenu_ExitGame;
    Button* GuiButton_MainMenu_NewGame;
    Button* GuiButton_MainMenu_LoadGame;
    
    Player* player;
    Map* map2;
    
    // UI state flags
    bool ShowDebug = false;
    bool DrawCollisions = false;
    bool ShowOptions = false;
    bool ShowLoad = false;
    bool ShowHelp = false;
    bool muteMusic = false;
    
    // Helper methods
    void SetupMainMenu();
    void SetupGame();
    void CleanupGame();
    void HandleMainMenuEvents(SDL_Event* event);
    void HandlePlayStateEvents(SDL_Event* event);
};

#endif
```

2. **Create `Lion's Den/Game/Game.cpp`**:
   - Copy `OnInit()` code from `main.cpp` â†’ `OnGameInit()`
   - Copy `OnEvent()` code from `main.cpp` â†’ `OnGameEvent()`
   - Copy `OnUpdate()` code from `main.cpp` â†’ `OnGameUpdate()`
   - Copy `OnRender()` code from `main.cpp` â†’ `OnGameRender()`
   - Copy `OnCleanUp()` code from `main.cpp` â†’ `OnGameCleanup()`
   - Copy `SaveGame()`, `LoadGame()`, `NewGame()` functions
   - Copy `DrawOptionsMenu()`, `DrawLoadMenu()`, `DrawHelpMenu()`

3. **Update `Lion's Den/Engine.h`**:
   - Remove game-specific includes
   - Keep only engine core includes

4. **Update `Lion's Den/main.cpp`**:
   - Remove all global variables
   - Remove all game-specific code
   - Keep only:
```cpp
#include "Engine.h"
#include "Game/Game.h"

void Engine::OnInit() {
    Game::GetInstance().OnGameInit();
}

void Engine::OnEvent(SDL_Event* event, const Uint8* keyboardState) {
    Game::GetInstance().OnGameEvent(event, keyboardState);
}

void Engine::OnUpdate() {
    Game::GetInstance().OnGameUpdate();
}

void Engine::OnRender() {
    Game::GetInstance().OnGameRender();
}

void Engine::OnCleanUp() {
    Game::GetInstance().OnGameCleanup();
}

int main() {
    Engine engine;
    engine.Start();
    return 0;
}
```

**Testing**:
- [ ] Game compiles
- [ ] Game runs and shows main menu
- [ ] Can start new game
- [ ] Can load game
- [ ] All UI elements work
- [ ] Player can move and attack
- [ ] Save/Load works

**Checkpoint**: Game runs identically to before, but code is organized

**Rollback**: If issues, revert to backup branch

---

#### **Task 1.3: Update Project File** (15 min)
**Action**: Add new files to Visual Studio project

1. Open `Lion's Den.vcxproj` in text editor
2. Add new files to `<ItemGroup>` sections:
   - `Game/Game.h`
   - `Game/Game.cpp`
   - `Scenes/Scene.h`
   - `Scenes/Scene.cpp`
   - `Systems/SceneManager.h`
   - `Systems/SceneManager.cpp`

**Checkpoint**: Project compiles with new files included

---

### **Day 1 Summary**
- âœ… Code extracted from main.cpp
- âœ… Game logic in Game class
- âœ… Project structure organized
- âœ… Game still runs correctly

**Time Estimate**: 4-5 hours
**Difficulty**: Medium

---

## ðŸ“† **Day 2: Scene System Implementation**

### **Goal**: Create scene management system and convert game states to scenes

### **Tasks**

#### **Task 2.1: Implement Base Scene Class** (1-2 hours)
**Action**: Create Scene base class

**File: `Lion's Den/Scenes/Scene.h`**
```cpp
#ifndef SCENE_H_
#define SCENE_H_

#include "Core/Object.h"
#include <string>
#include <vector>

class Scene {
public:
    Scene(const std::string& name);
    virtual ~Scene();

    // Lifecycle methods (override in derived classes)
    virtual void OnEnter() = 0;      // Called when scene becomes active
    virtual void OnExit() = 0;        // Called when scene becomes inactive
    virtual void OnUpdate() = 0;      // Called each update frame
    virtual void OnRender() = 0;      // Called each render frame
    virtual void OnEvent(SDL_Event* event, const Uint8* keyboardState) = 0;
    
    // Scene management
    const std::string& GetName() const { return _name; }
    bool IsActive() const { return _isActive; }
    void SetActive(bool active);
    
    // Layer access
    Object* GetLayer(int index);
    void AddLayer();
    int GetLayerCount() const { return static_cast<int>(_layers.size()); }
    
protected:
    std::string _name;
    bool _isActive;
    std::vector<Object*> _layers;
};

#endif
```

**File: `Lion's Den/Scenes/Scene.cpp`**
```cpp
#include "Scene.h"
#include "Core/Engine.h"

Scene::Scene(const std::string& name) : _name(name), _isActive(false) {
    // Create default layers
    AddLayer(); // Layer 0: Game objects
    AddLayer(); // Layer 1: GUI
}

Scene::~Scene() {
    // Layers will be cleaned up by Object system
    for (auto* layer : _layers) {
        if (layer) {
            layer->DeleteLater();
        }
    }
    _layers.clear();
}

void Scene::SetActive(bool active) {
    if (_isActive == active) return;
    
    _isActive = active;
    if (active) {
        OnEnter();
    } else {
        OnExit();
    }
}

void Scene::AddLayer() {
    _layers.push_back(new Object());
}

Object* Scene::GetLayer(int index) {
    if (index >= 0 && index < static_cast<int>(_layers.size())) {
        return _layers[index];
    }
    return nullptr;
}
```

**Testing**:
- [ ] Scene class compiles
- [ ] Can create Scene instance
- [ ] Layers are created correctly

**Checkpoint**: Scene base class works

---

#### **Task 2.2: Implement Scene Manager** (1 hour)
**Action**: Create SceneManager singleton

**File: `Lion's Den/Systems/SceneManager.h`**
```cpp
#ifndef SCENE_MANAGER_H_
#define SCENE_MANAGER_H_

#include "Scenes/Scene.h"
#include <unordered_map>
#include <string>

class SceneManager {
public:
    static SceneManager& GetInstance();
    
    // Scene registration
    void RegisterScene(Scene* scene);
    void UnregisterScene(const std::string& sceneName);
    
    // Scene activation
    void SetActiveScene(const std::string& sceneName);
    Scene* GetActiveScene() const { return _activeScene; }
    Scene* GetScene(const std::string& sceneName);
    
    // Update/Render/Event delegation
    void Update();
    void Render();
    void HandleEvent(SDL_Event* event, const Uint8* keyboardState);
    
    // Cleanup
    void Shutdown();
    
private:
    SceneManager() = default;
    ~SceneManager() = default;
    SceneManager(const SceneManager&) = delete;
    SceneManager& operator=(const SceneManager&) = delete;
    
    std::unordered_map<std::string, Scene*> _scenes;
    Scene* _activeScene = nullptr;
    std::string _activeSceneName;
};

#endif
```

**File: `Lion's Den/Systems/SceneManager.cpp`**
```cpp
#include "SceneManager.h"

SceneManager& SceneManager::GetInstance() {
    static SceneManager instance;
    return instance;
}

void SceneManager::RegisterScene(Scene* scene) {
    if (scene) {
        _scenes[scene->GetName()] = scene;
    }
}

void SceneManager::UnregisterScene(const std::string& sceneName) {
    auto it = _scenes.find(sceneName);
    if (it != _scenes.end()) {
        if (_activeScene == it->second) {
            _activeScene = nullptr;
            _activeSceneName.clear();
        }
        _scenes.erase(it);
    }
}

void SceneManager::SetActiveScene(const std::string& sceneName) {
    auto it = _scenes.find(sceneName);
    if (it != _scenes.end()) {
        if (_activeScene) {
            _activeScene->SetActive(false);
        }
        _activeScene = it->second;
        _activeSceneName = sceneName;
        _activeScene->SetActive(true);
    }
}

Scene* SceneManager::GetScene(const std::string& sceneName) {
    auto it = _scenes.find(sceneName);
    return (it != _scenes.end()) ? it->second : nullptr;
}

void SceneManager::Update() {
    if (_activeScene) {
        _activeScene->OnUpdate();
    }
}

void SceneManager::Render() {
    if (_activeScene) {
        _activeScene->OnRender();
    }
}

void SceneManager::HandleEvent(SDL_Event* event, const Uint8* keyboardState) {
    if (_activeScene) {
        _activeScene->OnEvent(event, keyboardState);
    }
}

void SceneManager::Shutdown() {
    if (_activeScene) {
        _activeScene->SetActive(false);
        _activeScene = nullptr;
    }
    
    for (auto& pair : _scenes) {
        delete pair.second;
    }
    _scenes.clear();
}
```

**Testing**:
- [ ] SceneManager compiles
- [ ] Can register scenes
- [ ] Can switch between scenes
- [ ] Active scene receives updates

**Checkpoint**: SceneManager works

---

#### **Task 2.3: Create MainMenuScene** (2-3 hours)
**Action**: Extract main menu logic to scene

**File: `Lion's Den/Scenes/MainMenuScene.h`**
```cpp
#ifndef MAIN_MENU_SCENE_H_
#define MAIN_MENU_SCENE_H_

#include "Scene.h"
#include "GUI/Widgets/Box.h"
#include "GUI/Widgets/Button.h"

class MainMenuScene : public Scene {
public:
    MainMenuScene();
    virtual ~MainMenuScene();
    
    void OnEnter() override;
    void OnExit() override;
    void OnUpdate() override;
    void OnRender() override;
    void OnEvent(SDL_Event* event, const Uint8* keyboardState) override;
    
private:
    Box* _mainMenuBox;
    Button* _buttonNewGame;
    Button* _buttonLoadGame;
    Button* _buttonOptions;
    Button* _buttonExit;
    
    void SetupUI();
    void HandleButtonClicks();
};

#endif
```

**File: `Lion's Den/Scenes/MainMenuScene.cpp`**
- Extract main menu setup from `Game::OnGameInit()`
- Extract main menu event handling from `Game::OnGameEvent()`
- Extract main menu rendering from `Game::OnGameRender()`

**Steps**:
1. Copy main menu initialization code to `OnEnter()`
2. Copy main menu event handling to `OnEvent()`
3. Copy main menu rendering to `OnRender()`
4. Remove main menu code from `Game.cpp`

**Testing**:
- [ ] Main menu displays correctly
- [ ] Buttons work
- [ ] Can navigate to other menus

**Checkpoint**: MainMenuScene works independently

---

#### **Task 2.4: Create GameScene** (3-4 hours)
**Action**: Extract gameplay logic to scene

**File: `Lion's Den/Scenes/GameScene.h`**
```cpp
#ifndef GAME_SCENE_H_
#define GAME_SCENE_H_

#include "Scene.h"
#include "Player.h"
#include "Map.h"
#include "GUI/Widgets/StatsBar.h"
#include "GUI/Widgets/Inventory.h"

class GameScene : public Scene {
public:
    GameScene();
    virtual ~GameScene();
    
    void OnEnter() override;
    void OnExit() override;
    void OnUpdate() override;
    void OnRender() override;
    void OnEvent(SDL_Event* event, const Uint8* keyboardState) override;
    
    // Game management
    void LoadGame(const std::string& saveName);
    void NewGame(const std::string& saveName);
    void SaveGame();
    
private:
    Player* _player;
    Map* _map;
    StatsBar* _statsBar;
    Inventory* _inventory;
    
    bool _showDebug = false;
    bool _drawCollisions = false;
    
    void SetupGame();
    void CleanupGame();
    void HandlePause();
    void HandlePlayerDeath();
};

#endif
```

**File: `Lion's Den/Scenes/GameScene.cpp`**
- Extract gameplay initialization
- Extract gameplay update logic
- Extract gameplay rendering
- Extract gameplay event handling
- Move save/load logic here

**Testing**:
- [ ] Game scene initializes correctly
- [ ] Player can move and attack
- [ ] Monsters spawn and move
- [ ] UI elements work
- [ ] Save/Load works
- [ ] Pause menu works

**Checkpoint**: GameScene works independently

---

#### **Task 2.5: Integrate Scenes into Engine** (1 hour)
**Action**: Update Engine to use SceneManager

**File: `Lion's Den/Engine.cpp`** - Update methods:

```cpp
void Engine::Core_Update() {
    // ... existing engine update code ...
    
    if (Engine::Pause == false) {
        SceneManager::GetInstance().Update();
    }
}

void Engine::Core_Render() {
    // ... existing render setup ...
    
    SceneManager::GetInstance().Render();
    
    // ... existing render cleanup ...
}

void Engine::Core_Event(SDL_Event* event, const Uint8* keyboardState) {
    // ... existing event processing ...
    
    SceneManager::GetInstance().HandleEvent(event, keyboardState);
}
```

**File: `Lion's Den/Game/Game.cpp`** - Update initialization:

```cpp
void Game::OnGameInit() {
    // Register scenes
    SceneManager::GetInstance().RegisterScene(new MainMenuScene());
    SceneManager::GetInstance().RegisterScene(new GameScene());
    
    // Start with main menu
    SceneManager::GetInstance().SetActiveScene("MainMenu");
    
    // ... rest of initialization ...
}
```

**Testing**:
- [ ] Game starts with main menu
- [ ] Can switch to game scene
- [ ] Can return to main menu
- [ ] All functionality preserved

**Checkpoint**: Scene system fully integrated

---

### **Day 2 Summary**
- âœ… Scene base class implemented
- âœ… SceneManager working
- âœ… MainMenuScene created
- âœ… GameScene created
- âœ… Engine uses SceneManager

**Time Estimate**: 6-8 hours
**Difficulty**: Medium-Hard

---

## ðŸ“† **Day 3: Event System Implementation**

### **Goal**: Decouple objects using event system

### **Tasks**

#### **Task 3.1: Implement Event System** (2-3 hours)
**Action**: Create EventSystem singleton

**File: `Lion's Den/Systems/EventSystem.h`**
```cpp
#ifndef EVENT_SYSTEM_H_
#define EVENT_SYSTEM_H_

#include <functional>
#include <unordered_map>
#include <vector>
#include <string>
#include <memory>

class EventSystem {
public:
    using EventCallback = std::function<void(void*)>;
    using EventID = size_t;
    
    static EventSystem& GetInstance();
    
    // Subscribe to event (returns ID for unsubscribing)
    EventID Subscribe(const std::string& eventName, EventCallback callback);
    
    // Unsubscribe from event
    void Unsubscribe(const std::string& eventName, EventID id);
    
    // Emit event
    void Emit(const std::string& eventName, void* data = nullptr);
    
    // Clear all subscriptions
    void Clear();
    
private:
    EventSystem() = default;
    ~EventSystem() = default;
    EventSystem(const EventSystem&) = delete;
    EventSystem& operator=(const EventSystem&) = delete;
    
    struct Subscription {
        EventID id;
        EventCallback callback;
    };
    
    std::unordered_map<std::string, std::vector<Subscription>> _listeners;
    EventID _nextID = 1;
};

// Event Data Structures
struct PlayerDeathEvent {
    Player* player;
};

struct MonsterKilledEvent {
    Monster* monster;
    Player* killer;
};

struct ItemPickedUpEvent {
    Item* item;
    Player* player;
};

struct SceneChangeEvent {
    std::string fromScene;
    std::string toScene;
};

#endif
```

**File: `Lion's Den/Systems/EventSystem.cpp`**
```cpp
#include "EventSystem.h"

EventSystem& EventSystem::GetInstance() {
    static EventSystem instance;
    return instance;
}

EventSystem::EventID EventSystem::Subscribe(const std::string& eventName, EventCallback callback) {
    EventID id = _nextID++;
    _listeners[eventName].push_back({id, callback});
    return id;
}

void EventSystem::Unsubscribe(const std::string& eventName, EventID id) {
    auto it = _listeners.find(eventName);
    if (it != _listeners.end()) {
        auto& subs = it->second;
        subs.erase(
            std::remove_if(subs.begin(), subs.end(),
                [id](const Subscription& sub) { return sub.id == id; }),
            subs.end()
        );
    }
}

void EventSystem::Emit(const std::string& eventName, void* data) {
    auto it = _listeners.find(eventName);
    if (it != _listeners.end()) {
        for (const auto& sub : it->second) {
            sub.callback(data);
        }
    }
}

void EventSystem::Clear() {
    _listeners.clear();
    _nextID = 1;
}
```

**Testing**:
- [ ] EventSystem compiles
- [ ] Can subscribe to events
- [ ] Can emit events
- [ ] Callbacks are called correctly

**Checkpoint**: EventSystem works

---

#### **Task 3.2: Refactor Player to Use Events** (2 hours)
**Action**: Replace direct calls with events

**File: `Lion's Den/Player.cpp`** - Update death handling:

```cpp
// OLD:
void Player::Die() {
    isDead = true;
    // Direct calls removed
}

// NEW:
void Player::Die() {
    isDead = true;
    PlayerDeathEvent evt;
    evt.player = this;
    EventSystem::GetInstance().Emit("PlayerDeath", &evt);
}
```

**File: `Lion's Den/Scenes/GameScene.cpp`** - Subscribe to events:

```cpp
void GameScene::OnEnter() {
    SetupGame();
    
    // Subscribe to player death
    _playerDeathSubscription = EventSystem::GetInstance().Subscribe("PlayerDeath",
        [this](void* data) {
            PlayerDeathEvent* evt = static_cast<PlayerDeathEvent*>(data);
            this->HandlePlayerDeath(evt->player);
        });
}

void GameScene::OnExit() {
    EventSystem::GetInstance().Unsubscribe("PlayerDeath", _playerDeathSubscription);
    CleanupGame();
}
```

**Testing**:
- [ ] Player death triggers event
- [ ] GameScene handles death correctly
- [ ] No direct coupling between Player and GameScene

**Checkpoint**: Player uses events

---

#### **Task 3.3: Refactor Monster to Use Events** (1-2 hours)
**Action**: Add events for monster death, spawn, etc.

**Similar pattern to Player**:
- Monster death â†’ `MonsterKilledEvent`
- Monster spawn â†’ `MonsterSpawnedEvent`

**Testing**:
- [ ] Monster events work
- [ ] GameScene responds to monster events

**Checkpoint**: Monsters use events

---

#### **Task 3.4: Refactor UI to Use Events** (2 hours)
**Action**: Use events for UI updates

**Examples**:
- Player health changes â†’ `HealthChangedEvent`
- Inventory changes â†’ `InventoryChangedEvent`
- Stats update â†’ `StatsChangedEvent`

**Testing**:
- [ ] UI updates via events
- [ ] No direct Player â†’ UI coupling

**Checkpoint**: UI uses events

---

### **Day 3 Summary**
- âœ… EventSystem implemented
- âœ… Player uses events
- âœ… Monsters use events
- âœ… UI uses events
- âœ… Objects decoupled

**Time Estimate**: 6-8 hours
**Difficulty**: Medium

---

## ðŸ“† **Day 4: Component System Foundation**

### **Goal**: Create component system and refactor Player

### **Tasks**

#### **Task 4.1: Implement Component Base Class** (1-2 hours)
**Action**: Create Component system

**File: `Lion's Den/Components/Component.h`**
```cpp
#ifndef COMPONENT_H_
#define COMPONENT_H_

#include "Core/Object.h"

class Component {
public:
    Component(Object* owner);
    virtual ~Component();
    
    virtual void OnUpdate() {}
    virtual void OnRender() {}
    virtual void OnEvent(SDL_Event* event) {}
    
    Object* GetOwner() const { return _owner; }
    bool IsEnabled() const { return _enabled; }
    void SetEnabled(bool enabled) { _enabled = enabled; }
    
protected:
    Object* _owner;
    bool _enabled = true;
};

#endif
```

**File: `Lion's Den/Components/Component.cpp`**
```cpp
#include "Component.h"

Component::Component(Object* owner) : _owner(owner) {
    if (!_owner) {
        // Error: Component requires valid owner
    }
}

Component::~Component() {
}
```

**Testing**:
- [ ] Component class compiles
- [ ] Can create components

**Checkpoint**: Component base works

---

#### **Task 4.2: Create HealthComponent** (1 hour)
**Action**: Extract health logic to component

**File: `Lion's Den/Components/HealthComponent.h`**
```cpp
#ifndef HEALTH_COMPONENT_H_
#define HEALTH_COMPONENT_H_

#include "Component.h"

class HealthComponent : public Component {
public:
    HealthComponent(Object* owner, int maxHealth);
    
    int GetHealth() const { return _health; }
    int GetMaxHealth() const { return _maxHealth; }
    void TakeDamage(int damage);
    void Heal(int amount);
    bool IsDead() const { return _health <= 0; }
    
    void OnUpdate() override;
    
private:
    int _health;
    int _maxHealth;
};

#endif
```

**File: `Lion's Den/Components/HealthComponent.cpp`**
- Extract health logic from Player
- Emit events on health changes

**Testing**:
- [ ] HealthComponent works
- [ ] Can attach to objects

**Checkpoint**: HealthComponent works

---

#### **Task 4.3: Create MovementComponent** (1-2 hours)
**Action**: Extract movement logic

**Similar pattern to HealthComponent**

**Testing**:
- [ ] MovementComponent works
- [ ] Objects can move using component

**Checkpoint**: MovementComponent works

---

#### **Task 4.4: Refactor Player to Use Components** (2-3 hours)
**Action**: Replace Player logic with components

**File: `Lion's Den/Player.h`** - Add components:

```cpp
class Player : public Object {
private:
    HealthComponent* _health;
    MovementComponent* _movement;
    // ... other components
};
```

**File: `Lion's Den/Player.cpp`** - Update to use components:

```cpp
Player::Player() {
    _health = new HealthComponent(this, 100);
    _movement = new MovementComponent(this, 2.0f);
    // ... initialize components
}

void Player::OnUpdate() {
    if (_health) _health->OnUpdate();
    if (_movement) _movement->OnUpdate();
    // ... other updates
}
```

**Testing**:
- [ ] Player works with components
- [ ] All functionality preserved
- [ ] Components can be swapped/modified

**Checkpoint**: Player uses components

---

### **Day 4 Summary**
- âœ… Component system created
- âœ… HealthComponent implemented
- âœ… MovementComponent implemented
- âœ… Player refactored to use components

**Time Estimate**: 5-7 hours
**Difficulty**: Medium-Hard

---

## ðŸ“† **Day 5: Polish & Optimization**

### **Goal**: Clean up, optimize, and test everything

### **Tasks**

#### **Task 5.1: Remove All Global Variables** (2 hours)
**Action**: Ensure no globals remain

**Checklist**:
- [ ] No globals in main.cpp
- [ ] No globals in Game.cpp
- [ ] All state in scenes/components
- [ ] Use singletons where appropriate

**Testing**:
- [ ] Game compiles without globals
- [ ] All functionality works

**Checkpoint**: No globals remain

---

#### **Task 5.2: Code Cleanup** (2 hours)
**Action**: Clean up code

**Tasks**:
- Remove commented code
- Fix naming inconsistencies
- Add missing comments
- Ensure consistent formatting
- Remove unused includes

**Checkpoint**: Code is clean

---

#### **Task 5.3: Performance Testing** (1-2 hours)
**Action**: Test performance

**Tests**:
- Frame rate (should be same or better)
- Memory usage (check for leaks)
- Load times
- Scene switching speed

**Checkpoint**: Performance acceptable

---

#### **Task 5.4: Integration Testing** (2-3 hours)
**Action**: Test all features

**Test Checklist**:
- [ ] Main menu works
- [ ] New game works
- [ ] Load game works
- [ ] Save game works
- [ ] Player movement works
- [ ] Player combat works
- [ ] Monster AI works
- [ ] Inventory works
- [ ] UI updates correctly
- [ ] Pause menu works
- [ ] Options menu works
- [ ] Scene switching works
- [ ] Events fire correctly
- [ ] Components work correctly

**Checkpoint**: All features work

---

#### **Task 5.5: Documentation** (1 hour)
**Action**: Document new architecture

**Create**:
- Architecture overview document
- Component usage guide
- Event system reference
- Scene creation guide

**Checkpoint**: Documentation complete

---

### **Day 5 Summary**
- âœ… No globals
- âœ… Code cleaned
- âœ… Performance tested
- âœ… All features tested
- âœ… Documentation created

**Time Estimate**: 8-10 hours
**Difficulty**: Easy-Medium

---

## ðŸ”„ **Rollback Plan**

If issues arise at any point:

1. **Immediate Rollback**:
```bash
git stash  # Save current work
git checkout backup-before-refactor
```

2. **Partial Rollback**:
   - Keep working changes
   - Revert specific problematic files
   - Test incrementally

3. **Fix and Continue**:
   - Identify issue
   - Fix in current branch
   - Test thoroughly
   - Continue with plan

---

## âœ… **Final Checklist**

Before considering implementation complete:

- [ ] Game compiles without errors
- [ ] Game runs identically to before
- [ ] All scenes work independently
- [ ] Event system decouples objects
- [ ] Component system allows composition
- [ ] No global variables
- [ ] Code is organized and clean
- [ ] Performance is acceptable
- [ ] Documentation is complete
- [ ] All tests pass

---

## ðŸ“Š **Progress Tracking**

Use this to track daily progress:

**Day 1**: [ ] Complete
**Day 2**: [ ] Complete
**Day 3**: [ ] Complete
**Day 4**: [ ] Complete
**Day 5**: [ ] Complete

**Overall Progress**: ___%

---

## ðŸŽ¯ **Success Metrics**

Implementation is successful when:
1. âœ… Code is 50%+ more maintainable (measured by complexity)
2. âœ… New features can be added 2x faster
3. âœ… No functionality is lost
4. âœ… Performance is same or better
5. âœ… Code is easier to understand

---

*This plan provides step-by-step instructions for implementing all improvements. Follow it day by day, testing at each checkpoint.*
